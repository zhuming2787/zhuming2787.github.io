<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Zhuming&#39;博客</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>成为更好的自己</description>
    <pubDate>Wed, 20 Mar 2024 04:23:56 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>C++内存</title>
      <link>http://example.com/2024/03/19/C-%E5%86%85%E5%AD%98/</link>
      <guid>http://example.com/2024/03/19/C-%E5%86%85%E5%AD%98/</guid>
      <pubDate>Tue, 19 Mar 2024 09:41:02 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;堆和栈的区别&quot;&gt;&lt;a href=&quot;#堆和栈的区别&quot; class=&quot;headerlink&quot; title=&quot;堆和栈的区别&quot;&gt;&lt;/a&gt;堆和栈的区别&lt;/h4&gt;&lt;p&gt;1、堆栈空间分配不同。栈由操作系统自动分配释放，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放&lt;b</description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h4><p>1、堆栈空间分配不同。栈由操作系统自动分配释放，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放<br>2、堆栈缓存方式不同。堆使用的是一级缓存，<br>3、堆栈数据结构不同。堆类似数组结构，栈类似栈结构，先进后出<br>4、大小限制：栈的大小受系统可用内存的限制，但在实践中，堆的大小受限于操作系统和硬件的限制<br>5、栈不容易产生碎片，堆容易产生碎片<br>总的来说，栈适合于管理具有较短生命周期和固定大小的数据，而堆适合于管理具有动态生命周期和大小不确定的数据</p><h4 id="C-的内存管理"><a href="#C-的内存管理" class="headerlink" title="C++的内存管理"></a>C++的内存管理</h4><p>1、C++内存分成了五个区，分别是堆、栈、自由存储区、全局&#x2F;静态存储区和常量存储区。</p><p>2、内存泄漏是什么？<br>简单说就是申请了一个内存空间，使用完毕没有释放<br>解决方案：<br>1、良好的编码习惯；<br>2、使用智能指针<br>3、用一些常见的工具插件</p><h4 id="malloc和局部变量分配在堆还是栈"><a href="#malloc和局部变量分配在堆还是栈" class="headerlink" title="malloc和局部变量分配在堆还是栈"></a>malloc和局部变量分配在堆还是栈</h4><p>malloc是在堆上分配内存，跟new是一样的，需要程序员自己回收内存；局部变量是在栈中分配内存的，超过作用域就自动收回</p>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2024/03/19/C-%E5%86%85%E5%AD%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>（1.1.8）static</title>
      <link>http://example.com/2024/03/18/static/</link>
      <guid>http://example.com/2024/03/18/static/</guid>
      <pubDate>Mon, 18 Mar 2024 12:42:07 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;说说-static关键字的作用&quot;&gt;&lt;a href=&quot;#说说-static关键字的作用&quot; class=&quot;headerlink&quot; title=&quot;说说 static关键字的作用&quot;&gt;&lt;/a&gt;说说 static关键字的作用&lt;/h4&gt;&lt;p&gt;1、定义全局静态变量和局部静态变量&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="说说-static关键字的作用"><a href="#说说-static关键字的作用" class="headerlink" title="说说 static关键字的作用"></a>说说 static关键字的作用</h4><p>1、定义全局静态变量和局部静态变量<br>(在变量前加static关键字。初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。直到程序结束)<br>2、定义静态函数<br>(在函数返回类型加上static关键字，函数就被定义为静态函数，只能在本源文件中使用)<br>3、在变量前加上static，变量被定义为静态变量。<br>4、static也可以用来定义类中的静态成语变量:使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都共享这一块静态存储空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class student&#123;</span><br><span class="line">private:</span><br><span class="line">    static int count; //静态成员变量，必须由静态成员函数return出来</span><br><span class="line">public:</span><br><span class="line">    student()&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    static int getCount()&#123; //静态成员函数</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int student::count =0;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    student s1,s2,s3;</span><br><span class="line">    cout &lt;&lt; student::getCount() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（<strong>划重点，面试题常考</strong>）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。</p><hr><h4 id="总结-从变量和函数的角度来看static会产生静态变量和静态函数，从class上来看，static会产生静态成员变量和静态成员函数。"><a href="#总结-从变量和函数的角度来看static会产生静态变量和静态函数，从class上来看，static会产生静态成员变量和静态成员函数。" class="headerlink" title="总结:从变量和函数的角度来看static会产生静态变量和静态函数，从class上来看，static会产生静态成员变量和静态成员函数。"></a>总结:从变量和函数的角度来看static会产生静态变量和静态函数，从class上来看，static会产生静态成员变量和静态成员函数。</h4>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2024/03/18/static/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>（1.1.7）C++从代码到可执行二进制文件的过程</title>
      <link>http://example.com/2024/03/18/C-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/</link>
      <guid>http://example.com/2024/03/18/C-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/</guid>
      <pubDate>Mon, 18 Mar 2024 12:00:03 GMT</pubDate>
      
        
        
      <description>&lt;p&gt; C++与C语言类似，一个C++程序从源码到执行文件，有四个过程，&lt;strong&gt;预编译、编译、汇编、链接&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;首先，预编译：&quot;&gt;&lt;a href=&quot;#首先，预编译：&quot; class=&quot;headerlink&quot; title=&quot;首先，</description>
        
      
      
      
      <content:encoded><![CDATA[<p> C++与C语言类似，一个C++程序从源码到执行文件，有四个过程，<strong>预编译、编译、汇编、链接</strong></p><hr><h4 id="首先，预编译："><a href="#首先，预编译：" class="headerlink" title="首先，预编译："></a>首先，预编译：</h4><p>(1) 将所有的#define删除，并且展开所有宏定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define NUM 17</span><br><span class="line">#define DNUM NUM+NUM</span><br><span class="line">//则表达式 DNUM/2+NUM/2的值为?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//预编译是将DNUM转化成NUM+NUM，所以表达式变成了NUM+NUM/2+NUM/2</span><br><span class="line">//等等！答案不是34,原式=NUM+NUM/2+NUM/2=17+17/2+17/2=17+8+8=33!</span><br><span class="line">//C++里面采用的是floor整型计算,取整,去小数！</span><br></pre></td></tr></table></figure><p>(2) 处理所有的条件预编译指令，如#if、#ifdef</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifndef HEADER_FILE_NAME_H</span><br><span class="line">#define HEADER_FILE_NAME_H</span><br><span class="line">#include &quot;HEADER_FILE&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//作用1、防止头文件被多次包含</span><br><span class="line">2、使用#ifndef主要原因是为了避免重复定义，使代码模块化和可维护</span><br></pre></td></tr></table></figure><p>(3) 处理#include预编译指令，将被包含的文件插入该预编译指令中，这也是为什么第二点中会发生重复定义</p><p>(4) 过滤所有的注释&#x2F;&#x2F;<br>(5) 添加行号和文件名标识</p><h4 id="其次，编译"><a href="#其次，编译" class="headerlink" title="其次，编译"></a>其次，编译</h4><p>(1) 词法分析：将源代码的字符序列分割成一系列的记号<br>(2) 将预处理后的中间文件转换成汇编语言<br>(3) 这个步骤将源代码翻译成机器语言。生成对应的目标文件</p><h4 id="然后，汇编"><a href="#然后，汇编" class="headerlink" title="然后，汇编"></a>然后，汇编</h4><p>这个过程主要将汇编代码转换成机器可以执行的指令</p><h4 id="最后，链接"><a href="#最后，链接" class="headerlink" title="最后，链接"></a>最后，链接</h4><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。<br>(1) 静态链接： 链接的时候就把调用的函数或者过程链接到了生成的可执行文件的执行；生成的静态链接库<br>(2) 动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，找要链接的代码</p><p>通俗点讲就是：静态链接直接把头文件复制进去，而动态链接是可执行文件包含对库函数的引用，但实际的库文件不被复制，由操作系统动态地加载和链接这些库文件。各有优缺点。</p><h4 id="总结-预编译先处理-以及注释，编译将文件再转换成汇编语言，第三步汇编是把汇编语言转换成机器可以执行的指令，最后的链接就是选择静态链接还是动态链接"><a href="#总结-预编译先处理-以及注释，编译将文件再转换成汇编语言，第三步汇编是把汇编语言转换成机器可以执行的指令，最后的链接就是选择静态链接还是动态链接" class="headerlink" title="总结 : 预编译先处理#以及注释，编译将文件再转换成汇编语言，第三步汇编是把汇编语言转换成机器可以执行的指令，最后的链接就是选择静态链接还是动态链接"></a><strong>总结</strong> : 预编译先处理#以及注释，编译将文件再转换成汇编语言，第三步汇编是把汇编语言转换成机器可以执行的指令，最后的链接就是选择静态链接还是动态链接</h4>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2024/03/18/C-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>函数对象和函数指针</title>
      <link>http://example.com/2024/03/17/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</link>
      <guid>http://example.com/2024/03/17/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</guid>
      <pubDate>Sun, 17 Mar 2024 02:12:17 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;函数指针&quot;&gt;&lt;a href=&quot;#函数指针&quot; class=&quot;headerlink&quot; title=&quot;函数指针&quot;&gt;&lt;/a&gt;函数指针&lt;/h2&gt;&lt;p&gt;你可以声明一个指向函数的指针，并将其用作二元函数对象，例如:&lt;/p&gt;
&lt;figure class=&quot;highlight pl</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>你可以声明一个指向函数的指针，并将其用作二元函数对象，例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int add(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int (*binaryFunction)(int,int) = &amp;add; //函数指针</span><br><span class="line">int result = binaryFunction(3,5); //结果为8</span><br></pre></td></tr></table></figure><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>你可以定义一个类重载operator()来实现函数对象。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Add &#123;</span><br><span class="line">    int operator()(int a,int b)</span><br><span class="line">const &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Add add;</span><br><span class="line">int result = add(3,5);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2024/03/17/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C与C++的区别(面试模板第二天)</title>
      <link>http://example.com/2024/03/16/C%E4%B8%8EC-%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <guid>http://example.com/2024/03/16/C%E4%B8%8EC-%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <pubDate>Sat, 16 Mar 2024 12:34:41 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;1-C语言是C-的子集，C-可以很好的兼容C语言，但是C-又有很多新特性，如引用、智能指针、auto变量等&quot;&gt;&lt;a href=&quot;#1-C语言是C-的子集，C-可以很好的兼容C语言，但是C-又有很多新特性，如引用、智能指针、auto变量等&quot; class=&quot;heade</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="1-C语言是C-的子集，C-可以很好的兼容C语言，但是C-又有很多新特性，如引用、智能指针、auto变量等"><a href="#1-C语言是C-的子集，C-可以很好的兼容C语言，但是C-又有很多新特性，如引用、智能指针、auto变量等" class="headerlink" title="1.C语言是C++的子集，C++可以很好的兼容C语言，但是C++又有很多新特性，如引用、智能指针、auto变量等"></a>1.C语言是C++的子集，C++可以很好的兼容C语言，但是C++又有很多新特性，如引用、智能指针、auto变量等</h3><h3 id="2-C-是面向对象的编程语言；C语言是面向过程的编辑语言。"><a href="#2-C-是面向对象的编程语言；C语言是面向过程的编辑语言。" class="headerlink" title="2.C++是面向对象的编程语言；C语言是面向过程的编辑语言。"></a>2.C++是面向对象的编程语言；C语言是面向过程的编辑语言。</h3><hr><p><strong>面对对象</strong> ： 把世界万物当成一个对象class，包含本身的属性特性和行为(函数)<br><strong>面对过程</strong> ： 把一件事情分成很多步骤去做，比如一个事情分成了很多个函数，然后一个一个去调用</p><hr><h3 id="3-C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄漏等。而C-增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try-catch等等"><a href="#3-C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄漏等。而C-增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try-catch等等" class="headerlink" title="3.C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄漏等。而C++增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try-catch等等"></a>3.C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄漏等。而C++增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try-catch等等</h3><h3 id="4-C-可复用性高，C-引入了模板-template-的概念-后面在此基础上，实现了方便开发的标准模板库STL。-C-的STL库相对于C语言的函数库更灵活、更通用"><a href="#4-C-可复用性高，C-引入了模板-template-的概念-后面在此基础上，实现了方便开发的标准模板库STL。-C-的STL库相对于C语言的函数库更灵活、更通用" class="headerlink" title="4.C++可复用性高，C++引入了模板(template)的概念,后面在此基础上，实现了方便开发的标准模板库STL。 C++的STL库相对于C语言的函数库更灵活、更通用"></a>4.C++可复用性高，C++引入了模板(template)的概念,后面在此基础上，实现了方便开发的标准模板库STL。 C++的STL库相对于C语言的函数库更灵活、更通用</h3>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2024/03/16/C%E4%B8%8EC-%E7%9A%84%E5%8C%BA%E5%88%AB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>内存分区</title>
      <link>http://example.com/2024/03/16/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/</link>
      <guid>http://example.com/2024/03/16/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/</guid>
      <pubDate>Sat, 16 Mar 2024 12:26:15 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;内存分区模型&quot;&gt;&lt;a href=&quot;#内存分区模型&quot; class=&quot;headerlink&quot; title=&quot;内存分区模型&quot;&gt;&lt;/a&gt;内存分区模型&lt;/h2&gt;&lt;hr&gt;
&lt;h2 id=&quot;C-程序在执行时，将内存大致分为四个区域&quot;&gt;&lt;a href=&quot;#C-程序在执行时，将内存</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h2><hr><h2 id="C-程序在执行时，将内存大致分为四个区域"><a href="#C-程序在执行时，将内存大致分为四个区域" class="headerlink" title="C++程序在执行时，将内存大致分为四个区域"></a>C++程序在执行时，将内存大致分为四个区域</h2><ul><li><strong>代码区</strong>: 存放函数体的二进制代码，由操控系统进行管理</li><li><strong>全局区</strong>: 存放全局变量和静态变量(static以及常量(const)</li><li><strong>栈区</strong>: 由编译器自动分配释放，存放函数的参数值，局部变量等</li><li><strong>堆区</strong>: 由程序员分配和释放，new和delete</li></ul><hr><h2 id="内存四区的意义"><a href="#内存四区的意义" class="headerlink" title="内存四区的意义"></a>内存四区的意义</h2><p>不同区域存放的数据，赋予不同的生命周期</p>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2024/03/16/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>哈夫曼树</title>
      <link>http://example.com/2024/03/12/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</link>
      <guid>http://example.com/2024/03/12/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</guid>
      <pubDate>Tue, 12 Mar 2024 12:56:41 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;什么是哈夫曼树？&quot;&gt;&lt;a href=&quot;#什么是哈夫曼树？&quot; class=&quot;headerlink&quot; title=&quot;什么是哈夫曼树？&quot;&gt;&lt;/a&gt;什么是哈夫曼树？&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;哈夫曼树（Huffman Tree）是一种用于编码的树形数据结构，通常用于数据压缩</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="什么是哈夫曼树？"><a href="#什么是哈夫曼树？" class="headerlink" title="什么是哈夫曼树？"></a>什么是哈夫曼树？</h2><hr><p>哈夫曼树（Huffman Tree）是一种用于编码的树形数据结构，通常用于数据压缩算法中。哈夫曼树的特点是，频率较高的字符在树的顶部，频率较低的字符在树的底部，从而实现了不同字符的编码长度不同，且尽量短的目标。</p><p>哈夫曼树的构建过程通常是根据字符出现的频率来构建的，频率越高的字符在树中的位置越靠近树的根节点。构建哈夫曼树的基本思路是，首先将所有字符作为单独的节点，并按照频率从小到大排序。然后，将频率最低的两个节点合并为一个新节点，新节点的频率为两个节点的频率之和，并将新节点放入原来的节点列表中。重复这个过程，直到只剩下一个节点，即树的根节点。</p><p>哈夫曼树的一个重要应用是哈夫曼编码（Huffman Coding），它是一种变长编码方式，将字符映射为不定长的二进制编码。哈夫曼编码的特点是，频率较高的字符对应的编码较短，频率较低的字符对应的编码较长，从而实现了对数据的高效压缩。</p><p>总之，哈夫曼树是一种用于数据压缩的树形数据结构，通过根据字符频率构建树，实现了高效的数据压缩编码。</p><hr><h2 id="哈夫曼树的应用"><a href="#哈夫曼树的应用" class="headerlink" title="哈夫曼树的应用"></a>哈夫曼树的应用</h2><p>哈夫曼树是一种用于数据压缩的重要数据结构。它通常用于构建哈夫曼编码，是一种变长编码（即不同字符的编码长度可能不同）。</p><p>下面是哈夫曼树的一些常见应用：</p><p>数据压缩：哈夫曼树最经典的应用就是数据压缩。在数据传输和存储过程中，对于一些出现频率较高的字符，用较短的编码表示，而对于出现频率较低的字符，用较长的编码表示，这样可以减少数据的存储空间和传输带宽。</p><p>文件压缩：在文件压缩中，通常会使用哈夫曼编码对文件中的字符进行编码，从而实现文件的压缩。常见的压缩文件格式，如ZIP、GZIP等，都使用了哈夫曼树。</p><p>通信传输：在通信传输中，为了节省传输带宽，可以使用哈夫曼编码对通信中的数据进行编码。特别是在无线通信、移动通信等场景中，传输带宽有限，采用哈夫曼编码能够提高传输效率。</p><p>图像压缩：在图像压缩中，哈夫曼树可以用于对图像数据进行压缩编码，从而减少图像文件的存储空间。</p><p>音频压缩：在音频压缩中，哈夫曼编码也可以用于对音频数据进行压缩编码，减少音频文件的存储空间和传输带宽。</p><p>总之，哈夫曼树在数据压缩领域有着广泛的应用，能够帮助我们高效地压缩和传输数据，节省存储空间和传输成本。</p>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2024/03/12/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>单调栈</title>
      <link>http://example.com/2024/03/12/%E5%8D%95%E8%B0%83%E6%A0%88/</link>
      <guid>http://example.com/2024/03/12/%E5%8D%95%E8%B0%83%E6%A0%88/</guid>
      <pubDate>Tue, 12 Mar 2024 12:25:02 GMT</pubDate>
      
        
        
      <description>&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;单调栈&lt;/strong&gt;是一种常用的数据结构，主要用于解决一些与连续元素相关的问题。以下是单调栈的一些常见应用：&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;寻找下一个更大元素（Next Greater Element）：给定一个数组，对于数组中的每</description>
        
      
      
      
      <content:encoded><![CDATA[<hr><p><strong>单调栈</strong>是一种常用的数据结构，主要用于解决一些与连续元素相关的问题。以下是单调栈的一些常见应用：</p><hr><ul><li><p>寻找下一个更大元素（Next Greater Element）：给定一个数组，对于数组中的每个元素，找到右边第一个比它大的元素。这个问题可以使用单调递减栈来解决。遍历数组，将元素的索引入栈，如果当前元素比栈顶元素大，那么弹出栈顶元素，并将当前元素作为栈顶元素的下一个更大元素。<br>eg.<a href="https://www.luogu.com.cn/problem/P2947">奶牛问题(洛谷 P2947)</a>利用单调栈，将O(n²)优化成了O(n)</p></li><li><p>寻找下一个更小元素（Next Smaller Element）：类似于上述问题，给定一个数组，对于数组中的每个元素，找到右边第一个比它小的元素。这个问题可以使用单调递增栈来解决。</p></li><li><p>寻找最近更大元素（Closest Greater Element）：给定一个数组，对于数组中的每个元素，找到距离它最近且大于它的元素。这个问题可以使用单调递减栈来解决。遍历数组，如果当前元素比栈顶元素大，那么弹出栈顶元素，直到找到距离当前元素最近的更大元素。</p></li><li><p>寻找最近更小元素（Closest Smaller Element）：类似于上述问题，给定一个数组，对于数组中的每个元素，找到距离它最近且小于它的元素。这个问题可以使用单调递增栈来解决。</p></li></ul><hr><p>柱状图中最大矩形面积（Largest Rectangle in Histogram）：给定一个柱状图，找到面积最大的矩形。这个问题可以使用单调递增栈来解决。遍历柱状图，如果当前柱的高度小于栈顶柱的高度，则计算栈顶柱的面积，并更新最大面积。反之，将当前柱入栈。</p><p>接雨水（Trapping Rain Water）：给定一个数组，表示不同高度的墙，求解能够容纳多少雨水。这个问题可以使用单调递减栈来解决。遍历数组，如果当前元素比栈顶元素大，则计算两者之间能够容纳的雨水量，并累加到总雨水量中。</p><p>以上是单调栈的一些常见应用，它可以帮助我们解决许多与连续元素相关的问题，提高算法的效率并简化代码实现。</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%A0%88/">栈</category>
      
      
      <comments>http://example.com/2024/03/12/%E5%8D%95%E8%B0%83%E6%A0%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C++基础</title>
      <link>http://example.com/2024/03/10/C-%E5%9F%BA%E7%A1%80/</link>
      <guid>http://example.com/2024/03/10/C-%E5%9F%BA%E7%A1%80/</guid>
      <pubDate>Sun, 10 Mar 2024 12:02:12 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;C-基础&quot;&gt;&lt;a href=&quot;#C-基础&quot; class=&quot;headerlink&quot; title=&quot;C++ 基础&quot;&gt;&lt;/a&gt;C++ 基础&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-1-1-简述下C-语言的特点&quot;&gt;&lt;a href=&quot;#1-1-1-简述下C-语言的特点&quot; cl</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++ 基础"></a>C++ 基础</h2><hr><h3 id="1-1-1-简述下C-语言的特点"><a href="#1-1-1-简述下C-语言的特点" class="headerlink" title="1.1.1 简述下C++语言的特点"></a>1.1.1 简述下C++语言的特点</h3><ol><li>C++在C语言的基础上引入了<strong>面对对象</strong>的机制，同时也兼容C语言<br>(面对对象：把一切事物抽象，然后对每个事物的性质和行为进行分析,而面向过程指将一件事情按照步骤进行)</li><li>C++有三大特性: (1). 封装 (2). 继承 (3). 多态<br>(封装：就是将一个类的信息隐藏在类的内部，不允许外界直接访问，而是提供某些方法实现对隐藏信息的访问和操作。封装的好处就是增强了<strong>数据安全性</strong>，也方便了类的实现和修改)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class student&#123;</span><br><span class="line">public:  //公共权限  类内可以访问 类外可以访问</span><br><span class="line">    string School;</span><br><span class="line">protected: //保护权限 类内可以访问 类外不可以访问</span><br><span class="line">    string PhoneNumber;</span><br><span class="line">private: //私有权限 类内可以访问 类外不可以访问</span><br><span class="line">    int Birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&emsp;(继承：类与类之间的一种关系。让子类继承父类的特征和行为。好处在于实现了代码的复用)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class BasePage&#123;</span><br><span class="line">public:...</span><br><span class="line">protected:...</span><br><span class="line">private:...</span><br><span class="line">&#125;</span><br><span class="line">class Java : public BasePage&#123;...&#125;</span><br></pre></td></tr></table></figure>&emsp;继承方式：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public: int a;</span><br><span class="line">protected: int b;</span><br><span class="line">private: int c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B:public A //第一种方法</span><br><span class="line">&#123;</span><br><span class="line">public: int a;</span><br><span class="line">protected: int b;</span><br><span class="line">不可访问: int c;</span><br><span class="line">&#125;</span><br><span class="line">class B:protected A //第二种方法</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">int a;int b;</span><br><span class="line">不可访问：int c;</span><br><span class="line">&#125;</span><br><span class="line">class B:private A //第三种方法</span><br><span class="line">&#123;</span><br><span class="line">private:int a int b;</span><br><span class="line">不可访问: int c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="struct和class唯一区别在于默认的访问权限不同"><a href="#struct和class唯一区别在于默认的访问权限不同" class="headerlink" title="struct和class唯一区别在于默认的访问权限不同"></a>struct和class唯一区别在于默认的访问权限不同</h4><h6 id="struct默认公共；class默认私有"><a href="#struct默认公共；class默认私有" class="headerlink" title="struct默认公共；class默认私有"></a><code>struct</code>默认公共；<code>class</code>默认私有</h6><hr><p>(多态：指的是一个类对象的相同方法在不同情形下有不同的表现形式。使得不同内部结构的对象可以共享相同的外部接口)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>C++语言编写出的程序结构清晰、易于扩充，程序可读性好。</li><li>C++生成的代码质量高，运行效率高、仅比汇编语言慢10%~20%</li><li>C++更加安全，增加了const常量，引用，四类cast转化、智能指针等</li><li>C++可复用性高、引入了模板的概念、比如标准模板库STL</li><li>最后，C++是不断在发展的语言。C++后续版本更是更新发展了不少新特性比如nullptr、auto变量等</li></ol><hr>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E5%9F%BA%E7%A1%80/">基础</category>
      
      
      <comments>http://example.com/2024/03/10/C-%E5%9F%BA%E7%A1%80/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>链表</title>
      <link>http://example.com/2024/03/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</link>
      <guid>http://example.com/2024/03/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</guid>
      <pubDate>Sat, 09 Mar 2024 12:27:08 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么是链表？&quot;&gt;&lt;a href=&quot;#什么是链表？&quot; class=&quot;headerlink&quot; title=&quot;什么是链表？&quot;&gt;&lt;/a&gt;什么是链表？&lt;/h2&gt;&lt;p&gt;&amp;emsp;如图&lt;br&gt;&lt;img src=&quot;https://pic</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li></li></ul><h2 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h2><p>&emsp;如图<br><img src="https://pic4.zhimg.com/v2-3a42e577405f60a79294ce207dcba53e_r.jpg"><br><strong>链表</strong>的特点:用一组位于任意位置的存储单元存储线性表的数据元素</p><p><strong>代码实现链表的方法</strong>:<br>动态链表：工程上为了节省空间经常使用<br>静态链表：算法竞赛里面经常使用,而且会直接使用STL list</p><hr>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">基础数据结构</category>
      
      
      <comments>http://example.com/2024/03/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
